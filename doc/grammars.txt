BNF
◊ One popular grammar notation is BNF (Backus-Naur
Form)
◊ BNF is commonly used in the definition of programming
languages

Grammar Rules in Prolog

◊ A grammar comprises production rules
Based on Chapter 9 in Clocksin & Mellish

G-1

A Simple Grammar in BNF

G-2

Generating Sentences
◊ A grammar can be used to generate a string of symbols
called a sentence

< s > ::= a b
< s > ::= a < s > b

◊ Start with a non-terminal
◊ Make substitutions using production rules

◊ S is enclosed by < > which indicates s is a non-terminal

◊ Terminate when the current sequence doesn’t contain
any non-terminal symbols

◊ A and b are terminal symbols
◊ Terminal symbols can never be rewritten

G-3

G-4

Generating Sentences - 2

Generating Sentences - 3

< s > ::= a b

< s > ::= a b

< s > ::= a < s > b

< s > ::= a < s > b

◊ Our grammar (given above) can generate sentences
(strings) of what form???

◊ Our grammar (given above) can generate sentences
(strings) of what form???

Answer:

anbn

n = 1, 2, 3, …

◊ The set of sentences generated by the grammar is called
the language defined by the grammar

G-5

Another Example Grammar

G-6

Another Example Grammar - 2

◊ A robot arm can be sent sequences of commands:

◊ A robot arm can be sent sequences of commands:

» up: move 1 step upward
» down: move 1 step downward

» up: move 1 step upward
» down: move 1 step downward

◊ What is a grammar to capture the robot’s possible
movements??

◊ What is a grammar to capture the robot’s possible
movements??

< move > ::= < step >
< move > ::= < step > < move >
< step > ::= up
< step > ::= down

G-7

G-8

Parsing in Prolog

Parsing in Prolog - 2

◊ A grammar generates sentences

◊ In Prolog it is easy to write a parsing program using
special grammar rule notation called DCG (definite
clause grammar)

◊ A grammar can also be used to recognize a given
sentence

◊ Most Prolog implementations support this special
notation for grammars

◊ Recognition is really the opposite of generation (ie
determine whether a sentence is part of a language as
opposed to generating a sentence that is part of a
language)

◊ Very easy to change BNF to DCG

◊ Sometimes it is called parsing

G-9

From BNF to DCG - 1

G-10

From BNF to DCG - 2

◊ Starting with our simple example in BNF

◊ Note the differences between BNF and DCG notations:

» ::= is replaced by -->
» Non-terminals are not in brackets any more
» Terminals are in square brackets (making them

< s > ::= a b
< s > ::= a < s > b

Prolog lists)
◊ Converting it to DCG

» Symbols are separated by commas
» Each rule is terminated by a full stop (like every
other Prolog clause)

s --> [ a ], [ b ].
s --> [ a ], s, [ b ].

G-11

G-12

From BNF to DCG - 3

From BNF to DCG - 4

◊ Starting with our robot are example in BNF

◊ Starting with our robot are example in BNF

< move > ::= < step >

< move > ::= < step >

< move > ::= < step > < move >

< move > ::= < step > < move >
< step > ::= up

< step > ::= up

< step > ::= down

< step > ::= down
◊ Converting it to DCG

◊ Converting it to DCG

?????

move --> step.
move --> step, move.
step --> [ up ].
step --> [ down ].

G-13

G-14

DCG Notation

Back to our First Example

◊ Each sentence is represented by 2 lists

s --> [ a ], [ b ].

◊ Difference lists of terminal symbols

s --> [ a ], s, [ b ].

◊ Can think of first list as the sentence you are parsing and
the second list as the part of the sentence that is left-over
after the parsing is done

?- s( [ a, a, b, b ], [ ] ).
yes
?- s( [ a, b, b ], [ ] ).
no
?- s( [ a, a, b, b, c ], [ c ] ).
yes
?- s( [ a, a, c, b, b ], [ c ] ).
no

G-15

G-16

Back to our Second Example - 1

Back to our Second Example - 2
?- move( [ up, up, down ], [ ] ).
yes

move --> step.

?- move( [ up, up, down ], [ down ] ).

move --> step, move.

yes

step --> [ up ].

?- move( [ up, up, left ], [ ] ).

step --> [ down ].

no
?- move( [ up, up, left ], [ left ] ).
yes
?- move( [ up, X, up ], [ ] ).
X = up ;
X = down ;
G-17

How Does Prolog DCGs Work? - 1

G-18

no

How Does Prolog DCGs Work? - 2

◊ When Prolog consults grammar rules it turns them into
normal Prolog clauses

◊ If the DCG rule is

» n --> n1, n2, … , nn.

◊ Uses simple rules to turn grammar rules into clauses
depending on whether the symbols on the right-hand side
of the rules are

» All non-terminals
» A mix of terminals and non-terminals
» All terminals

◊ If all the n1, n2, … nn are non-terminals then the rule is
translated into the clause:

» n( List1, Rest ) :n1( List1, List2 ),
n2( List2, List3 ),
…
nn( Listn, Rest ).

G-19

G-20

How Does Prolog DCGs Work? - 3

How Does Prolog DCGs Work? - 4

◊ If the DCG rule is

◊ If the DCG rule is

» n --> n1, [t2], n3, [t4].
» Where n1 and n3 are non-terminals and t2 and t4 are

» n --> [ t1 ], [t2].
» Where t1 and t2 are terminals

terminals
◊ Then the DCG rule is translated into the following clause:

◊ Then the DCG rule is translated into the following clause:

» n( [ t1, t2 | Rest ], Rest ).

» n( List1, Rest ) :n1( List1, [ t2 | List3 ] ),
n3( List3, [ t4 | Rest ] ).

G-21

Translating Example 1

G-22

Translating Example 1 - 2

◊ Translate the following DCG grammar into Prolog
clauses:

◊ Translate the following DCG grammar into Prolog
clauses:

s --> [ a ], [ b ].

s --> [ a ], [ b ].

s --> [ a ], s, [ b ].

s --> [ a ], s, [ b ].

s( [ a, b | Rest ], Rest ).
s( [ a | List1 ], Rest ) :s( List1, [ b | Rest ] ).

G-23

G-24

Translating Example 2

Translating Example 2 - 2

◊ Translate the following DCG grammar into Prolog
clauses:

◊ Translate the following DCG grammar into Prolog
clauses:

move --> step.

move --> step.

move --> step, move.

move --> step, move.
step --> [ up ].

step --> [ up ].

step --> [ down ].

step --> [ down ].

move( List, Rest ) :step( List, Rest ).
move( List1, Rest ) :step( List1, List2),
move( List2, Rest ).
step( [ up | Rest ], Rest ).
step( [ down | Rest ], Rest ).
G-25

A More Interesting Example

G-26

A More Interesting Example - 2

◊ More interesting examples of grammars come from
programming languages and natural languages

sentence --> noun_phrase, verb_phrase.
verb_phrase --> verb, noun_phrase.

◊ Here is an example grammar for a simple subset of
English:
sentence --> noun_phrase, verb_phrase.

noun_phrase --> determiner, noun.
determiner --> [ a ].
determiner --> [ the ].

verb_phrase --> verb, noun_phrase.

noun --> [ cat ].

noun_phrase --> determiner, noun.

noun --> [ mouse ].

determiner --> [ a ].

verb --> [ scares ].

determiner --> [ the ].

verb --> [ hates ].
Example sentences generated by this grammar are:

noun --> [ cat ].
noun --> [ mouse ].

[ the, cat, scares, a, mouse ]

verb --> [ scares ].

[ the, mouse, hates, the, cat ]

verb --> [ hates ].

[ the, mouse, scares, the, mouse ]
G-27

G-28

Adding Extra Arguments - 1

Adding Extra Arguments - 2

◊ May want to have extra arguments in our parser apart
from the ones dealing with consumption of the input
series

◊ The following rules could be added to our grammar:
noun --> [ cats ]
noun --> [ mice ]

◊ For example, let us look at the problem of agreement
between the subject and the verb in a sentence

verb --> [ scare ]
verb --> [ hate ]

◊ We can add nouns and verbs in plural

◊ Now we can generate sentences like:
[ the, mice, hate, the, cats ]
◊ Unfortunately, it will also generate sentences like:
[ the, mouse, hate, the, cat ]

G-29

Adding Extra Arguments - 3

G-30

Adding Extra Arguments - 4

◊ The problem lies in the rule:
sentence --> noun_phrase, verb_phrase.
◊ This states that any noun phrase and verb phrase can be
put together to form a sentence
◊ But in English the noun phrase and verb phrase in a
sentence must agree in number

◊ Context dependencies cannot be directly handled by BNF
grammars, but they can be handled by DCG grammars
by adding arguments to non-terminal symbols
◊ So, we add Number as an argument and modify our
grammar

◊ Both must be singular or both must be plural

G-31

G-32

Adding Extra Arguments - 5

Adding Extra Arguments - 6
◊ Converting DCG rules with arguments into Prolog
clauses

sentence( Number ) --> noun_phrase( Number), verb_phrase
( Number ).
verb_phrase( Number ) --> verb( Number ),
(Number1).

noun_phrase

◊ When DCG rules are converted to Prolog clauses, the
arguments on non-terminals are simply added to the
usual two list arguments, with the two lists coming last.

noun_phrase( Number ) --> determiner( Number ), noun
( Number ).
determiner( singular ) --> [ a ].

◊ For example:

determiner( Number ) --> [ the ].

sentence( Number ) --> noun_phrase( Number ),
verb_phrase( Number ).

noun( singular ) --> [ cat ].
noun( plural ) --> [ cats ].
noun( singular ) --> [ mouse ].

◊ Is converted into:

noun( plural ) --> [ mice ].

sentence( Number, List1, Rest ):-

verb( singular ) --> [ scares ].
verb( plural ) --> [ scare ].

noun_phrase( Number, List1, List2 ),

verb( singular ) --> [ hates ].

verb_phrase( Number, List2, Rest ).

verb( plural ) --> [ hate ].
G-33

Examples with an Extra Argument

G-34

Parse Trees
◊ The parse tree of a phrase is a tree with the following
properties:

?- sentence( plural, [ the, mice, hate, the, cats ], [ ] ).
yes

» All the leaves of the tree are labelled by terminal

?- sentence( plural, [ the, mouse, hates, the, cat ], [ ] ).

symbols of the grammar

no

» All the internal nodes of the tree are labelled by

?- sentence( Number, [ the, mouse, hates, the, cat ], [ ] ).

non-terminal symbols; the root of the tree is
labelled by the non-terminal that corresponds to
the phrase

Number = singular
?- sentence( singular, [ the, What, hates, the, cat ], [ ] ).

» The parent-children relation in the tree is as

What = cat ;

specified by the rules of the grammar

What = mouse ;
no
?- sentence( plural, [ the, mice, hate, the, cat, a, lot ], [ a, lot ] ).
yes
G-35

G-36

Parse Trees - 2

Parse Trees - 3

◊ Sometimes it is useful to have the parse tree explicitly
represented in the program to perform some computation
on it. For example to extract the meaning of a sentence.

◊ The parse tree of a noun phrase in our grammar has the
form
» noun_phrase( determiner( the ), noun( cat ) )

◊ The parse tree for the noun phrase “the cat” would be
represented as

◊ This represents the tree

» noun_phrase( determiner( the ), noun( cat ) )

noun_phrase

◊ To generate a parse tree, add to each non-terminal the
parse tree as an argument
determiner

the

noun

cat

G-37

G-38

Parse Trees - 4

Modified Grammar

◊ Adding the parse trees as arguments into our noun phase
grammar rule
noun_phrase --> determiner, noun.

sentence( Number, sentence( NP, VP )) -->
noun_phrase( Number, NP ), verb_phrase( Number, VP ).
verb_phrase( Number, verb_phrase( Verb, NP )) -->
verb( Number, Verb ), noun_phrase( Number1, NP ).

◊ Results in the modified rule
noun_phrase( noun_phrase( DetTree, NounTree) ) -->
determiner( DetTree ), noun( NounTree ).

noun_phrase( Number, noun_phrase( Det, Noun)) -->
determiner( Det ), noun( Number, Noun ).
determiner( determiner( the ) ) --> [ the ].

◊ This rule can be read as

noun( singular, noun( cat ) ) --> [ cat ].

» A noun phrase whose parse tree is noun_phrase
( DetTree, NounTree) consists of:

noun( plural, noun( cats ) ) --> [ cats ].

> A determiner whose parse tree is DetTree, and

etc. etc.

> A noun whose parse tree is NounTree
G-39

G-40

Modified Grammar - 2

Modified Grammar - Example

◊ When this grammar is read by Prolog it is automatically
translated into a standard Prolog program.

?- sentence( Number, ParseTree, [ the, mice, hate, the,
cat ], [ ] ).

◊ The first grammar rule:

Number = plural

sentence( Number, sentence( NP, VP )) -->

ParseTree = sentence( noun_phrase( determiner( the ),
noun( mice ) ), verb_phrase( verb( hate ), noun_phrase
( determiner( the ), noun( cat ) ) ) )

noun_phrase( Number, NP ),
verb_phrase( Number, VP ).

?- noun_phrase( plural, ParseTree, [ the, mice, hate, the,
cat ], Leftover ).

◊ Is translated into:
sentence( Number, sentence( NP, VP), List, Rest ) :-

ParseTree = noun_phrase( determiner( the ), noun( mice ) )

noun_phrase( Number, NP, List, Rest0 ),

Leftover = [ hate, the, cat ]

verb_phrase( Number, VP, Rest0, Rest ).

G-41

Adding Extra Tests

G-42

Example – Extra Tests

◊ So far, everything mentioned in the grammar rules has
had to do with how the input sequence is consumed

◊ Consider the robot arm example again:
move --> step.

◊ Every goal in the resulting Prolog clause has been
involved with consuming some amount of input

move --> step, move.
step --> [ up ].

◊ Sometimes we want to specify goals not of this type

step --> [ down ].

◊ Any goals enclosed in curly brackets { } are to be left
unchanged by the translator

◊ Now, we want to define the distance the robot has moved
as the difference between the robot’s position before the
move and after the move.
◊ Let each step be 1mm in either the positive or negative
direction
◊ So, the program [ up, up, down, up ] would be equivalent
to a distance of 2 mm
G-43

G-44

Example – Extra Tests - 2

Example – Extra Tests - 3

◊ To accomplish our goal we have to add the move’s
distance as an argument

◊ To accomplish our goal we have to add the move’s distance as
an argument

◊ To the old grammar

◊ To the old grammar
move --> step.

move --> step.

move --> step, move.

move --> step, move.

step --> [ up ].

step --> [ up ].

step --> [ down ].

step --> [ down ].

◊ So, we get a revised grammar

◊ So, we get a revised grammar

move( D ) --> step( D ).
move( D ) --> step( D1 ), move( D2 ), { D is D1 + D2 }.
step( 1 ) --> [ up ].

????

step( -1 ) --> [ down ].

G-45

G-46

A Final Example

A Final Example - 2

◊ Lets make our robot arm example more interesting.
Suppose the robot can be in 1 of 2 gears: g1 or g2.
When a step command is received in gear g1 the robot
will move by 1 mm up or down. In gear, g2 it will move
by 2 mm. The program for the robot should consist of
gear commands, step commands and a stop command
(ending the program)

◊ Example programs are:
stop
Returns a distance of 0
g1 up up stop
Returns a distance of 2
g1 up up g2 down up stop
Returns a distance of 1 + 1 + 2 * (-1 + 1) = 2
g1 g1 g2 up up g1 up down up g2 stop
Returns a distance of 2 * (1 + 1) + 1 – 1 + 1 = 5

G-47

G-48

A Final Example - 3

A Final Example - 4

◊ Here is our grammar with distance but without gears:

◊ Here is our grammar with distance but without gears:
move( D ) --> step( D ).

move( D ) --> step( D ).

move( D ) --> step( D1 ), move( D2 ), { D is D1 + D2 }.

move( D ) --> step( D1 ), move( D2 ), { D is D1 + D2 }.

step( 1 ) --> [ up ].

step( 1 ) --> [ up ].

step( -1 ) --> [ down ].

step( -1 ) --> [ down ].
◊ Extend it with the following new rules to handle the gears

◊ We need to extend it with new rules to handle the gears

prog( 0 ) --> [ stop ].
prog( Dist ) --> gear( _ ), prog( Dist ).
prog( Dist ) --> gear( G ), move( D ), prog( Dist1 ),
{ Dist is G * D + Dist1 }.
gear( 1 ) --> [ g1 ].
G-49

gear( 2 ) --> [ g2 ].

G-50

